// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {GGRaffle} from "../src/GG_Raffle.sol";
import {stdJson} from "forge-std/StdJson.sol";
import {Test, console} from "forge-std/Test.sol";
import {SP1VerifierGateway} from "@sp1-contracts/SP1VerifierGateway.sol";
import {ECDSA} from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import {DrandOracle} from "@drand-oracle/DrandOracle.sol";
import {GGIRaffle, IDrandOracle} from "../src/GG_IRaffle.sol";

/// @notice A struct representing the SP1 proof fixture. This is generated by the zk/script/src/bin/evm.rs script.
/// @dev Forge requires the fields to be in alphabetical order - https://book.getfoundry.sh/cheatcodes/parse-json?highlight=alphabetical%20order#decoding-json-objects-into-solidity-structs
struct SP1ProofFixtureJson {
    bytes32 merkleRoot;
    uint32 numParticipants;
    uint32 numWinners;
    bytes proof;
    bytes publicValues;
    bytes32 randomness;
    bytes32 vkey;
}

contract GGRaffleTest is Test {
    using stdJson for string;

    uint256 internal ownerPrivateKey;
    uint256 internal signerPrivateKey;
    address internal owner;
    address internal signer;
    address internal verifier;
    address internal drandOracle;
    string constant verifierName = "Galxe GG Raffle";
    string constant verifierVersion = "1.0.0";

    GGRaffle public raffle;
    uint64 internal constant questID = 123;
    uint64 internal constant questRevealTimestamp = 1;

    bytes32 internal constant _TYPE_HASH =
    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
    bytes32 _HASHED_NAME;
    bytes32 _HASHED_VERSION;

    function loadFixture() public view returns (SP1ProofFixtureJson memory) {
        string memory root = vm.projectRoot();
        string memory path = string.concat(
            root,
            "../../zk/fixtures/groth16-1000-10-82e8b6bbf24681c9d3c928f988aa6eef88f41f164e5df290e3dca3b8f6ce3f07-fixture.json"
        );
        string memory json = vm.readFile(path);
        bytes memory jsonBytes = json.parseRaw(".");
        return abi.decode(jsonBytes, (SP1ProofFixtureJson));
    }

    function setUp() public {
        SP1ProofFixtureJson memory fixture = loadFixture();

        ownerPrivateKey = 0xA11CE;
        signerPrivateKey = 0xB0B;
        owner = vm.addr(ownerPrivateKey);
        signer = vm.addr(signerPrivateKey);

        verifier = address(new SP1VerifierGateway(address(1)));
        // initialise drand oracle, using a random byte32 chain hash
        drandOracle = address(
            new DrandOracle(address(2), address(3), 0x8990e7a9aaed2ffed73dbd7092123d6f289930540d7651336225dc172e51b2ce)
        );
        raffle = new GGRaffle(owner, signer, verifier, fixture.vkey, drandOracle);

        bytes32 hashedName = keccak256(bytes(verifierName));
        bytes32 hashedVersion = keccak256(bytes(verifierVersion));
        _HASHED_NAME = hashedName;
        _HASHED_VERSION = hashedVersion;
    }

    function test_e2e_success() public {
        SP1ProofFixtureJson memory fixture = loadFixture();
        vm.mockCall(
            verifier,
            abi.encodeWithSelector(SP1VerifierGateway.verifyProof.selector),
            abi.encode(true)
        );
        vm.mockCall(
            drandOracle,
            abi.encodeWithSelector(IDrandOracle.getRandomnessFromTimestamp.selector),
            abi.encode(
                IDrandOracle.Random({
                    round: 1,
                    timestamp: questRevealTimestamp,
                    randomness: fixture.randomness,
                    signature: "0x1234"
                })
            )
        );

        // generate participants
        for (uint256 i = 0; i < fixture.numParticipants; i++) {
            // generate new participant address
            uint256 newUser = uint256(i) + 1; // private key cannot be 0
            // generate verify id
            uint256 verifyID = uint256(i) + 1;
            // generate signature
            (uint8 v, bytes32 r, bytes32 s) =
                                vm.sign(signerPrivateKey, _hashParticipate(questID, newUser, verifyID));
            bytes memory signature = abi.encodePacked(r, s, v);
            // console.logBytes32(_hashParticipate(questID, newUser, verifyID));
            // console.log("Raw signature:", vm.toString(signature));
            // participate
            raffle.participate(questID, newUser, verifyID, signature);
        }

        // commit randomness
        (uint8 rv, bytes32 rr, bytes32 rs) =
                            vm.sign(signerPrivateKey, _hashCommitRandomness(questID, questRevealTimestamp));
        bytes memory randomnessSignature = abi.encodePacked(rr, rs, rv);
        raffle.commitRandomness(questID, questRevealTimestamp, randomnessSignature);

        // reveal
        raffle.reveal(questID, 1, fixture.publicValues, fixture.proof);

        // verify quest state
        (
            bool active,
            IDrandOracle.Random memory random,
            uint256 participantCount,
            uint256 winnerCount,
            bytes32 merkleRoot
        ) = raffle.getQuest(questID, 1);
        assertEq(random.round, 1);
        assertEq(random.randomness, fixture.randomness);
        assertEq(participantCount, fixture.numParticipants);
        assertEq(winnerCount, fixture.numWinners);
        assertEq(active, false);
        assertEq(merkleRoot, fixture.merkleRoot);
    }

    function test_e2e_batch_success() public {
        SP1ProofFixtureJson memory fixture = loadFixture();
        vm.mockCall(
            verifier,
            abi.encodeWithSelector(SP1VerifierGateway.verifyProof.selector),
            abi.encode(true)
        );
        vm.mockCall(
            drandOracle,
            abi.encodeWithSelector(IDrandOracle.getRandomnessFromTimestamp.selector),
            abi.encode(
                IDrandOracle.Random({
                    round: 1,
                    timestamp: questRevealTimestamp,
                    randomness: fixture.randomness,
                    signature: "0x1234"
                })
            )
        );

        // generate participants
        uint256 count = 10;
        for (uint256 i = 0; i < fixture.numParticipants; i += count) {

            // generate new participant address
            uint256 newUser = uint256(i) + 1; // private key cannot be 0

            // generate verifyIDs
            uint256[] memory verifyIDs = new uint256[](count);
            for (uint256 j = 0; j < count; j++) {
                verifyIDs[j] = uint256(i) + j + 1;
            }
            // generate signature
            (uint8 v, bytes32 r, bytes32 s) =
                                vm.sign(signerPrivateKey, _hashParticipateBatch(questID, newUser, verifyIDs));
            bytes memory signature = abi.encodePacked(r, s, v);
            // console.logBytes32(_hashParticipate(questID, newUser, verifyID));
            // console.log("Raw signature:", vm.toString(signature));
            // participate
            raffle.participateBatch(questID, newUser, verifyIDs, signature);
        }

        // commit randomness
        (uint8 rv, bytes32 rr, bytes32 rs) =
                            vm.sign(signerPrivateKey, _hashCommitRandomness(questID, questRevealTimestamp));
        bytes memory randomnessSignature = abi.encodePacked(rr, rs, rv);
        raffle.commitRandomness(questID, questRevealTimestamp, randomnessSignature);

        // reveal
        raffle.reveal(questID, 2, fixture.publicValues, fixture.proof);

        // verify quest state
        (
            bool active,
            IDrandOracle.Random memory random,
            uint256 participantCount,
            uint256 winnerCount,
            bytes32 merkleRoot
        ) = raffle.getQuest(questID, 2);
        assertEq(random.round, 1);
        assertEq(random.randomness, fixture.randomness);
        assertEq(participantCount, fixture.numParticipants);
        assertEq(winnerCount, fixture.numWinners);
        assertEq(active, false);
        assertEq(merkleRoot, fixture.merkleRoot);
    }

    /// @notice Tests that the commit randomness fails if a randomness commit has already been made - quest is already not active
    function test_commit_randomness_failure_multiple_commit() public {
        SP1ProofFixtureJson memory fixture = loadFixture();
        vm.mockCall(verifier, abi.encodeWithSelector(SP1VerifierGateway.verifyProof.selector), abi.encode(true));
        vm.mockCall(
            drandOracle,
            abi.encodeWithSelector(IDrandOracle.getRandomnessFromTimestamp.selector),
            abi.encode(
                IDrandOracle.Random({
                    round: 1,
                    timestamp: questRevealTimestamp,
                    randomness: fixture.randomness,
                    signature: "0x1234"
                })
            )
        );

        // generate participants
        for (uint256 i = 0; i < fixture.numParticipants; i++) {
            // generate new participant address
            uint256 newUser = uint256(i) + 1; // private key cannot be 0
            // generate verify id
            uint256 verifyID = uint256(i) + 1;
            // generate signature
            (uint8 v, bytes32 r, bytes32 s) =
                                vm.sign(signerPrivateKey, _hashParticipate(questID, newUser, verifyID));
            bytes memory signature = abi.encodePacked(r, s, v);
            // participate
            raffle.participate(questID, newUser, verifyID, signature);
        }

        // commit randomness - ok
        (uint8 rv, bytes32 rr, bytes32 rs) =
                            vm.sign(signerPrivateKey, _hashCommitRandomness(questID, questRevealTimestamp));
        bytes memory randomnessSignature = abi.encodePacked(rr, rs, rv);
        raffle.commitRandomness(questID, questRevealTimestamp, randomnessSignature);

        // commit randomness - fail
        vm.expectRevert(abi.encodeWithSelector(GGIRaffle.QuestNotActive.selector));
        raffle.commitRandomness(questID, questRevealTimestamp, randomnessSignature);
    }

    function test_reveal_failure_already_revealed() public {
        SP1ProofFixtureJson memory fixture = loadFixture();
        vm.mockCall(verifier, abi.encodeWithSelector(SP1VerifierGateway.verifyProof.selector), abi.encode(true));
        vm.mockCall(
            drandOracle,
            abi.encodeWithSelector(IDrandOracle.getRandomnessFromTimestamp.selector),
            abi.encode(
                IDrandOracle.Random({
                    round: 1,
                    timestamp: questRevealTimestamp,
                    randomness: fixture.randomness,
                    signature: "0x1234"
                })
            )
        );

        // generate participants
        for (uint256 i = 0; i < fixture.numParticipants; i++) {
            // generate new participant address
            uint256 newUser = uint256(i) + 1; // private key cannot be 0
            // generate verify id
            uint256 verifyID = uint256(i) + 1;
            // generate signature
            (uint8 v, bytes32 r, bytes32 s) =
                                vm.sign(signerPrivateKey, _hashParticipate(questID, newUser, verifyID));
            bytes memory signature = abi.encodePacked(r, s, v);
            // participate
            raffle.participate(questID, newUser, verifyID, signature);
        }

        (uint8 rv, bytes32 rr, bytes32 rs) =
                            vm.sign(signerPrivateKey, _hashCommitRandomness(questID, questRevealTimestamp));
        bytes memory randomnessSignature = abi.encodePacked(rr, rs, rv);
        raffle.commitRandomness(questID, questRevealTimestamp, randomnessSignature);

        // reveal
        raffle.reveal(questID, 1, fixture.publicValues, fixture.proof);

        // reveal again
        vm.expectRevert(abi.encodeWithSelector(GGIRaffle.QuestAlreadyRevealed.selector));
        raffle.reveal(questID, 1, fixture.publicValues, fixture.proof);
    }

    /// @notice Tests that the reveal fails if the zk proof is incorrect - i.e. proof is valid but public values are incorrect
    function test_reveal_failure_incorrect_zk_proof() public {
        SP1ProofFixtureJson memory fixture = loadFixture();
        vm.mockCall(verifier, abi.encodeWithSelector(SP1VerifierGateway.verifyProof.selector), abi.encode(true));
        vm.mockCall(
            drandOracle,
            abi.encodeWithSelector(IDrandOracle.getRandomnessFromTimestamp.selector),
            abi.encode(
                IDrandOracle.Random({
                    round: 1,
                    timestamp: questRevealTimestamp,
                    randomness: fixture.randomness,
                    signature: "0x1234"
                })
            )
        );

        // generate participants
        for (uint256 i = 0; i < fixture.numParticipants; i++) {
            // generate new participant address
            uint256 newUser = uint256(i) + 1; // private key cannot be 0
            // generate verify id
            uint64 verifyID = uint64(i) + 1;
            // generate signature
            (uint8 v, bytes32 r, bytes32 s) =
                                vm.sign(signerPrivateKey, _hashParticipate(questID, newUser, verifyID));
            bytes memory signature = abi.encodePacked(r, s, v);
            // participate
            raffle.participate(questID, newUser, verifyID, signature);
        }

        (uint8 rv, bytes32 rr, bytes32 rs) =
                            vm.sign(signerPrivateKey, _hashCommitRandomness(questID, questRevealTimestamp));
        bytes memory randomnessSignature = abi.encodePacked(rr, rs, rv);
        raffle.commitRandomness(questID, questRevealTimestamp, randomnessSignature);

        // reveal
        // modify the public values to be incorrect
        (uint32 participantCount, uint32 winnerCount, bytes32 randomness, bytes32 merkleRoot) =
                            abi.decode(fixture.publicValues, (uint32, uint32, bytes32, bytes32));
        bytes memory incorrectPublicValues = abi.encode(participantCount + 1, winnerCount, randomness, merkleRoot);

        vm.expectRevert(abi.encodeWithSelector(GGIRaffle.IncorrectProof.selector));
        raffle.reveal(questID, 1, incorrectPublicValues, fixture.proof);

        // retry reveal with correct public values
        raffle.reveal(questID, 1, fixture.publicValues, fixture.proof);
    }

    // --------------- hash functions ------------- //
    function _hashParticipate(uint256 _questID, uint256 _user, uint256 _verifyID) private view returns (bytes32) {
        return _hashTypedDataV4(
            keccak256(
                abi.encode(
                    keccak256("Participate(uint256 questID,uint256 user,uint256 verifyID)"),
                    _questID,
                    _user,
                    _verifyID
                )
            )
        );
    }

    function _hashParticipateBatch(uint256 _questID, uint256 _user, uint256[] memory _verifyIDs) private view returns (bytes32) {
        return _hashTypedDataV4(
            keccak256(
                abi.encode(
                    keccak256("ParticipateBatch(uint256 questID,uint256 user,uint256[] verifyIDs)"),
                    _questID,
                    _user,
                    keccak256(abi.encodePacked(_verifyIDs))
                )
            )
        );
    }

    function _hashCommitRandomness(uint256 _questID, uint256 _timestamp) private view returns (bytes32) {
        return _hashTypedDataV4(
            keccak256(
                abi.encode(
                    keccak256("CommitRandomness(uint256 questID,uint256 timestamp)"),
                    _questID,
                    _timestamp
                )
            )
        );
    }

    function _hashReveal(uint256 _questID, uint256 _roundID, bytes memory _randomness) private view returns (bytes32) {
        return _hashTypedDataV4(
            keccak256(
                abi.encode(
                    keccak256("Reveal(uint256 questID,uint256 roundID,bytes randomness)"),
                    _questID,
                    _roundID,
                    keccak256(_randomness)
                )
            )
        );
    }

    // --------------- EIP712 signature tools ------------- //
    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {
        return keccak256(abi.encodePacked("\x19\x01", _buildDomainSeparator(), structHash));
    }

    function _buildDomainSeparator() private view returns (bytes32) {
        return keccak256(abi.encode(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION, _getChainId(), address(raffle)));
    }

    function _getChainId() private view returns (uint256 chainId) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        // solhint-disable-next-line no-inline-assembly
        assembly {
            chainId := chainid()
        }
    }
}
