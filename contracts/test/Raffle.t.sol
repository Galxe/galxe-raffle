// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Raffle} from "../src/Raffle.sol";
import {stdJson} from "forge-std/StdJson.sol";
import {Test, console} from "forge-std/Test.sol";
import {SP1VerifierGateway} from "@sp1-contracts/SP1VerifierGateway.sol";
import {ECDSA} from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import {IRaffle} from "../interface/IRaffle.sol";

/// @notice A struct representing the SP1 proof fixture. This is generated by the zk/script/src/bin/evm.rs script.
/// @dev Forge requires the fields to be in alphabetical order - https://book.getfoundry.sh/cheatcodes/parse-json?highlight=alphabetical%20order#decoding-json-objects-into-solidity-structs
struct SP1ProofFixtureJson {
    bytes32 merkleRoot;
    uint32 numParticipants;
    uint32 numWinners;
    bytes proof;
    bytes publicValues;
    bytes32 randomness;
    bytes32 vkey;
}

contract RaffleTest is Test {
    using stdJson for string;

    uint256 internal ownerPrivateKey;
    uint256 internal signerPrivateKey;
    address internal owner;
    address internal signer;
    address internal verifier;

    string constant verifierName = "Galxe Raffle";
    string constant verifierVersion = "1.0.0";

    Raffle public raffle;
    uint64 internal constant questID = 123;

    bytes32 internal constant _TYPE_HASH =
        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
    bytes32 _HASHED_NAME;
    bytes32 _HASHED_VERSION;

    function loadFixture() public view returns (SP1ProofFixtureJson memory) {
        string memory root = vm.projectRoot();
        string memory path = string.concat(
            root,
            "/test/fixtures/groth16-1000-10-82e8b6bbf24681c9d3c928f988aa6eef88f41f164e5df290e3dca3b8f6ce3f07-fixture.json"
        );
        string memory json = vm.readFile(path);
        bytes memory jsonBytes = json.parseRaw(".");
        return abi.decode(jsonBytes, (SP1ProofFixtureJson));
    }

    function setUp() public {
        SP1ProofFixtureJson memory fixture = loadFixture();

        ownerPrivateKey = 0xA11CE;
        signerPrivateKey = 0xB0B;
        owner = vm.addr(ownerPrivateKey);
        signer = vm.addr(signerPrivateKey);

        verifier = address(new SP1VerifierGateway(address(1)));
        raffle = new Raffle(owner, signer, verifier, fixture.vkey);

        bytes32 hashedName = keccak256(bytes(verifierName));
        bytes32 hashedVersion = keccak256(bytes(verifierVersion));
        _HASHED_NAME = hashedName;
        _HASHED_VERSION = hashedVersion;
    }

    function test_e2e_success() public {
        SP1ProofFixtureJson memory fixture = loadFixture();
        vm.mockCall(verifier, abi.encodeWithSelector(SP1VerifierGateway.verifyProof.selector), abi.encode(true));

        // generate participants
        for (uint256 i = 0; i < fixture.numParticipants; i++) {
            // generate new participant address
            uint256 newParticipant = uint256(i) + 1; // private key cannot be 0
            // generate verify id
            uint64 verifyID = uint64(i) + 1;
            // generate signature
            (uint8 v, bytes32 r, bytes32 s) =
                vm.sign(signerPrivateKey, _hashParticipate(questID, newParticipant, verifyID));
            bytes memory signature = abi.encodePacked(r, s, v);
            // participate
            raffle.participate(questID, newParticipant, verifyID, signature);
        }

        // commit randomness
        IRaffle.DrandBeacon memory inputBeacon = IRaffle.DrandBeacon({
            round: 1,
            randomness: fixture.randomness,
            signature: "0x1234",
            previousSignature: "0x5678"
        });
        (uint8 rv, bytes32 rr, bytes32 rs) = vm.sign(signerPrivateKey, _hashCommitRandomness(questID, inputBeacon));
        bytes memory randomnessSignature = abi.encodePacked(rr, rs, rv);
        raffle.commitRandomness(questID, inputBeacon, randomnessSignature);

        // reveal
        raffle.reveal(questID, fixture.publicValues, fixture.proof);

        // verify quest state
        (bool active, IRaffle.DrandBeacon memory resultBeacon, bytes32 merkleRoot) = raffle.getQuest(questID);
        assertEq(resultBeacon.round, inputBeacon.round);
        assertEq(resultBeacon.randomness, fixture.randomness);
        assertEq(active, false);
        assertEq(merkleRoot, fixture.merkleRoot);
    }

    /// @notice Tests that the commit randomness fails if a randomness commit has already been made - quest is already not active
    function test_commit_randomness_failure_multiple_commit() public {
        SP1ProofFixtureJson memory fixture = loadFixture();
        vm.mockCall(verifier, abi.encodeWithSelector(SP1VerifierGateway.verifyProof.selector), abi.encode(true));

        // generate participants
        for (uint256 i = 0; i < fixture.numParticipants; i++) {
            // generate new participant address
            uint256 newParticipant = uint256(i) + 1; // private key cannot be 0
            // generate verify id
            uint64 verifyID = uint64(i) + 1;
            // generate signature
            (uint8 v, bytes32 r, bytes32 s) =
                vm.sign(signerPrivateKey, _hashParticipate(questID, newParticipant, verifyID));
            bytes memory signature = abi.encodePacked(r, s, v);
            // participate
            raffle.participate(questID, newParticipant, verifyID, signature);
        }

        // commit randomness - ok
        IRaffle.DrandBeacon memory inputBeacon = IRaffle.DrandBeacon({
            round: 1,
            randomness: fixture.randomness,
            signature: "0x1234",
            previousSignature: "0x5678"
        });
        (uint8 rv, bytes32 rr, bytes32 rs) = vm.sign(signerPrivateKey, _hashCommitRandomness(questID, inputBeacon));
        bytes memory randomnessSignature = abi.encodePacked(rr, rs, rv);
        raffle.commitRandomness(questID, inputBeacon, randomnessSignature);

        // commit randomness - fail
        vm.expectRevert(abi.encodeWithSelector(IRaffle.QuestNotActive.selector));
        raffle.commitRandomness(questID, inputBeacon, randomnessSignature);
    }

    function test_reveal_failure_already_revealed() public {
        SP1ProofFixtureJson memory fixture = loadFixture();
        vm.mockCall(verifier, abi.encodeWithSelector(SP1VerifierGateway.verifyProof.selector), abi.encode(true));

        // generate participants
        for (uint256 i = 0; i < fixture.numParticipants; i++) {
            // generate new participant address
            uint256 newParticipant = uint256(i) + 1; // private key cannot be 0
            // generate verify id
            uint64 verifyID = uint64(i) + 1;
            // generate signature
            (uint8 v, bytes32 r, bytes32 s) =
                vm.sign(signerPrivateKey, _hashParticipate(questID, newParticipant, verifyID));
            bytes memory signature = abi.encodePacked(r, s, v);
            // participate
            raffle.participate(questID, newParticipant, verifyID, signature);
        }

        // commit randomness
        IRaffle.DrandBeacon memory inputBeacon = IRaffle.DrandBeacon({
            round: 1,
            randomness: fixture.randomness,
            signature: "0x1234",
            previousSignature: "0x5678"
        });
        (uint8 rv, bytes32 rr, bytes32 rs) = vm.sign(signerPrivateKey, _hashCommitRandomness(questID, inputBeacon));
        bytes memory randomnessSignature = abi.encodePacked(rr, rs, rv);
        raffle.commitRandomness(questID, inputBeacon, randomnessSignature);

        // reveal
        raffle.reveal(questID, fixture.publicValues, fixture.proof);

        // reveal again
        vm.expectRevert(abi.encodeWithSelector(IRaffle.QuestAlreadyRevealed.selector));
        raffle.reveal(questID, fixture.publicValues, fixture.proof);
    }

    /// @notice Tests that the reveal fails if the zk proof is incorrect - i.e. proof is valid but public values are incorrect
    function test_reveal_failure_incorrect_zk_proof() public {
        SP1ProofFixtureJson memory fixture = loadFixture();
        vm.mockCall(verifier, abi.encodeWithSelector(SP1VerifierGateway.verifyProof.selector), abi.encode(true));

        // generate participants
        for (uint256 i = 0; i < fixture.numParticipants; i++) {
            // generate new participant address
            uint256 newParticipant = uint256(i) + 1; // private key cannot be 0
            // generate verify id
            uint64 verifyID = uint64(i) + 1;
            // generate signature
            (uint8 v, bytes32 r, bytes32 s) =
                vm.sign(signerPrivateKey, _hashParticipate(questID, newParticipant, verifyID));
            bytes memory signature = abi.encodePacked(r, s, v);
            // participate
            raffle.participate(questID, newParticipant, verifyID, signature);
        }

        // commit randomness
        IRaffle.DrandBeacon memory inputBeacon = IRaffle.DrandBeacon({
            round: 1,
            randomness: fixture.randomness,
            signature: "0x1234",
            previousSignature: "0x5678"
        });
        (uint8 rv, bytes32 rr, bytes32 rs) = vm.sign(signerPrivateKey, _hashCommitRandomness(questID, inputBeacon));
        bytes memory randomnessSignature = abi.encodePacked(rr, rs, rv);
        raffle.commitRandomness(questID, inputBeacon, randomnessSignature);

        // reveal
        // modify the public values to be incorrect
        (uint32 participantCount, uint32 winnerCount, bytes32 randomness, bytes32 merkleRoot) =
            abi.decode(fixture.publicValues, (uint32, uint32, bytes32, bytes32));
        bytes memory incorrectPublicValues = abi.encode(participantCount + 1, winnerCount, randomness, merkleRoot);

        vm.expectRevert(abi.encodeWithSelector(IRaffle.IncorrectProof.selector));
        raffle.reveal(questID, incorrectPublicValues, fixture.proof);

        // retry reveal with correct public values
        raffle.reveal(questID, fixture.publicValues, fixture.proof);
    }

    // --------------- hash functions ------------- //
    function _hashParticipate(uint64 _questID, uint256 _user, uint64 _verifyID) private view returns (bytes32) {
        return _hashTypedDataV4(
            keccak256(
                abi.encode(
                    keccak256("Participate(uint64 questID,uint256 user,uint64 verifyID)"), _questID, _user, _verifyID
                )
            )
        );
    }

    function _hashCommitRandomness(uint64 _questID, IRaffle.DrandBeacon memory _beacon)
        private
        view
        returns (bytes32)
    {
        return _hashTypedDataV4(
            keccak256(
                abi.encode(
                    keccak256(
                        "CommitRandomness(uint64 questID,uint64 round,bytes32 randomness,bytes signature,bytes previousSignature)"
                    ),
                    _questID,
                    _beacon.round,
                    _beacon.randomness,
                    keccak256(_beacon.signature),
                    keccak256(_beacon.previousSignature)
                )
            )
        );
    }

    function _hashReveal(uint64 _questID, uint64 _roundID, bytes memory _randomness) private view returns (bytes32) {
        return _hashTypedDataV4(
            keccak256(
                abi.encode(
                    keccak256("Reveal(uint64 questID,uint64 roundID,bytes randomness)"),
                    _questID,
                    _roundID,
                    keccak256(_randomness)
                )
            )
        );
    }

    // --------------- EIP712 signature tools ------------- //
    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {
        return keccak256(abi.encodePacked("\x19\x01", _buildDomainSeparator(), structHash));
    }

    function _buildDomainSeparator() private view returns (bytes32) {
        return keccak256(abi.encode(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION, _getChainId(), address(raffle)));
    }

    function _getChainId() private view returns (uint256 chainId) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        // solhint-disable-next-line no-inline-assembly
        assembly {
            chainId := chainid()
        }
    }
}
