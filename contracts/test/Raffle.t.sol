// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Raffle} from "../src/Raffle.sol";
import {stdJson} from "forge-std/StdJson.sol";
import {Test, console} from "forge-std/Test.sol";
import {SP1VerifierGateway} from "@sp1-contracts/SP1VerifierGateway.sol";
import {ECDSA} from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

/// @notice A struct representing the SP1 proof fixture. This is generated by the zk/script/src/bin/evm.rs script.
/// @dev Forge requires the fields to be in alphabetical order - https://book.getfoundry.sh/cheatcodes/parse-json?highlight=alphabetical%20order#decoding-json-objects-into-solidity-structs
struct SP1ProofFixtureJson {
    bytes32 merkleRoot;
    uint32 numParticipants;
    uint32 numWinners;
    bytes proof;
    bytes publicValues;
    uint64 randomSeed;
    bytes32 vkey;
}

contract RaffleTest is Test {
    using stdJson for string;

    uint256 internal ownerPrivateKey;
    uint256 internal signerPrivateKey;
    address internal owner;
    address internal signer;
    address internal verifier;

    string constant verifierName = "Galxe Raffle";
    string constant verifierVersion = "1.0.0";

    Raffle public raffle;
    uint64 internal constant questID = 123;

    bytes32 internal constant _TYPE_HASH =
        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
    bytes32 _HASHED_NAME;
    bytes32 _HASHED_VERSION;

    function loadFixture() public view returns (SP1ProofFixtureJson memory) {
        string memory root = vm.projectRoot();
        string memory path = string.concat(root, "/test/fixtures/groth16-fixture.json");
        string memory json = vm.readFile(path);
        bytes memory jsonBytes = json.parseRaw(".");
        return abi.decode(jsonBytes, (SP1ProofFixtureJson));
    }

    function setUp() public {
        SP1ProofFixtureJson memory fixture = loadFixture();

        ownerPrivateKey = 0xA11CE;
        signerPrivateKey = 0xB0B;
        owner = vm.addr(ownerPrivateKey);
        signer = vm.addr(signerPrivateKey);

        verifier = address(new SP1VerifierGateway(address(1)));
        raffle = new Raffle(owner, signer, verifier, fixture.vkey);

        bytes32 hashedName = keccak256(bytes(verifierName));
        bytes32 hashedVersion = keccak256(bytes(verifierVersion));
        _HASHED_NAME = hashedName;
        _HASHED_VERSION = hashedVersion;
    }

    function test_e2e_success() public {
        SP1ProofFixtureJson memory fixture = loadFixture();
        vm.mockCall(verifier, abi.encodeWithSelector(SP1VerifierGateway.verifyProof.selector), abi.encode(true));

        // generate participants
        for (uint256 i = 0; i < fixture.numParticipants; i++) {
            // generate new participant address
            uint256 newParticipant = uint256(i) + 1; // private key cannot be 0
            // generate verify id
            uint64 verifyID = uint64(i) + 1;
            // generate signature
            (uint8 v, bytes32 r, bytes32 s) =
                vm.sign(signerPrivateKey, _hashParticipate(questID, newParticipant, verifyID));
            bytes memory signature = abi.encodePacked(r, s, v);
            // participate
            raffle.participate(questID, newParticipant, verifyID, signature);
        }

        // commit randomness
        uint64 drandRoundID = 1;
        (uint8 rv, bytes32 rr, bytes32 rs) = vm.sign(
            signerPrivateKey, _hashCommitRandomness(questID, drandRoundID, abi.encodePacked(fixture.randomSeed))
        );
        bytes memory randomnessSignature = abi.encodePacked(rr, rs, rv);
        raffle.commitRandomness(questID, drandRoundID, abi.encodePacked(fixture.randomSeed), randomnessSignature);

        // reveal
        raffle.reveal(questID, fixture.publicValues, fixture.proof);

        // verify quest state
        (uint64 roundID, bytes memory randomness, bool active, bytes32 merkleRoot) = raffle.getQuest(questID);
        assertEq(roundID, drandRoundID);
        assertEq(randomness, abi.encodePacked(fixture.randomSeed));
        assertEq(active, false);
        assertEq(merkleRoot, fixture.merkleRoot);
    }

    // --------------- hash functions ------------- //
    function _hashParticipate(uint64 _questID, uint256 _user, uint64 _verifyID) private view returns (bytes32) {
        return _hashTypedDataV4(
            keccak256(
                abi.encode(
                    keccak256("Participate(uint64 questID,uint256 user,uint64 verifyID)"), _questID, _user, _verifyID
                )
            )
        );
    }

    function _hashCommitRandomness(uint64 _questID, uint64 _roundID, bytes memory _randomness)
        private
        view
        returns (bytes32)
    {
        return _hashTypedDataV4(
            keccak256(
                abi.encode(
                    keccak256("CommitRandomness(uint64 questID,uint64 roundID,bytes randomness)"),
                    _questID,
                    _roundID,
                    keccak256(_randomness)
                )
            )
        );
    }

    function _hashReveal(uint64 _questID, uint64 _roundID, bytes memory _randomness) private view returns (bytes32) {
        return _hashTypedDataV4(
            keccak256(
                abi.encode(
                    keccak256("Reveal(uint64 questID,uint64 roundID,bytes randomness)"),
                    _questID,
                    _roundID,
                    keccak256(_randomness)
                )
            )
        );
    }

    // --------------- EIP712 signature tools ------------- //
    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {
        return keccak256(abi.encodePacked("\x19\x01", _buildDomainSeparator(), structHash));
    }

    function _buildDomainSeparator() private view returns (bytes32) {
        return keccak256(abi.encode(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION, _getChainId(), address(raffle)));
    }

    function _getChainId() private view returns (uint256 chainId) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        // solhint-disable-next-line no-inline-assembly
        assembly {
            chainId := chainid()
        }
    }
}
